<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hand-Tracked Particle System (12 Shapes)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffcc; 
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
            z-index: 10;
        }
        h1 { margin: 0; font-size: 24px; text-transform: uppercase; }
        .hud-box {
            background: rgba(0, 20, 20, 0.85);
            padding: 15px;
            border: 1px solid #00ffcc;
            border-radius: 4px;
            margin-top: 10px;
            width: 220px;
        }
        .status-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .highlight { color: #fff; font-weight: bold; }
        
        #video-wrapper {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border: 1px solid #333;
            transform: scaleX(-1);
            opacity: 0.5;
            z-index: 5;
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* --- New Error/Info Box Styles --- */
        #error-info {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #400000;
            color: #ffcccc;
            border: 2px solid #ff3333;
            padding: 30px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 0 20px rgba(255, 51, 51, 0.5);
            z-index: 1000;
            text-align: center;
            border-radius: 8px;
            display: none; /* Hidden by default */
        }
        #error-info a { color: #ff9999; font-weight: bold; text-decoration: underline; }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>Particle Core</h1>
        <div class="hud-box">
            <div class="status-row"><span>SHAPE:</span> <span id="shape-name" class="highlight">SPHERE</span></div>
            <div class="status-row"><span>INDEX:</span> <span id="shape-index" class="highlight">1 / 12</span></div>
            <hr style="border-color: #333">
            <p>‚úä <strong>Fist:</strong> Gravity Well (Attract)</p>
            <p>üëã <strong>Open Hand:</strong> Expand / Explode</p>
            <p>üëå <strong>Pinch:</strong> Next Shape</p>
        </div>
    </div>

    <div id="video-wrapper">
        <video id="input-video"></video>
    </div>

    <div id="error-info">
        </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- CONFIG ---
        const PARTICLE_COUNT = 5000;
        const PARTICLE_SIZE = 0.1;
        
        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 16;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- STATE ---
        let particles;
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        
        // 12 Shapes List
        const shapes = [
            'sphere', 'sunflower', 'dna', 'cube', 
            'galaxy', 'heart', 'pyramid', 'torus', 
            'cone', 'cylinder', 'wave', 'ring'
        ];
        
        let currentShapeIndex = 0;
        let time = 0;

        // Hand State
        let handPos = new THREE.Vector3(0,0,0);
        let isHandPresent = false;
        let isFist = false;
        let isPinching = false;
        let pinchTimer = 0;

        // --- INIT ---
        function init() {
            initParticles();
            calculateTargets(shapes[0]);
            setupCamera(); 
        }

        function initParticles() {
            const geometry = new THREE.BufferGeometry();
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Initial random position
                positions[i*3] = (Math.random()-0.5)*10;
                positions[i*3+1] = (Math.random()-0.5)*10;
                positions[i*3+2] = (Math.random()-0.5)*10;
                
                // Initial Color (Cyan)
                colors[i*3] = 0; colors[i*3+1] = 1; colors[i*3+2] = 1;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Create a soft glow texture
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; 
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                map: texture,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- THE MATH CORE (All 12 Shapes) ---
        function calculateTargets(shape) {
            document.getElementById('shape-name').innerText = shape.toUpperCase();
            document.getElementById('shape-index').innerText = (currentShapeIndex + 1) + " / " + shapes.length;

            const scale = 6; 
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x = 0, y = 0, z = 0;
                const idx = i / PARTICLE_COUNT; // 0 to 1
                const angle = idx * Math.PI * 2;

                if (shape === 'sphere') {
                    const r = scale;
                    const phi = Math.acos( -1 + ( 2 * idx ) );
                    const theta = Math.sqrt( PARTICLE_COUNT * Math.PI ) * phi;
                    x = r * Math.cos( theta ) * Math.sin( phi );
                    y = r * Math.sin( theta ) * Math.sin( phi );
                    z = r * Math.cos( phi );
                }
                else if (shape === 'sunflower') {
                    // PHYLLOTAXIS (Golden Angle)
                    const goldenAngle = Math.PI * (3 - Math.sqrt(5)); 
                    const r = scale * Math.sqrt(idx); 
                    const theta = i * goldenAngle;
                    
                    x = r * Math.cos(theta);
                    y = r * Math.sin(theta);
                    z = (idx - 0.5) * 2; 
                }
                else if (shape === 'dna') {
                    const turns = 6;
                    const h = 12;
                    const r = 2.5;
                    const offset = (i % 2 === 0) ? 0 : Math.PI;
                    const t = idx * Math.PI * 2 * turns;
                    
                    x = Math.cos(t + offset) * r;
                    z = Math.sin(t + offset) * r;
                    y = (idx - 0.5) * h;
                    
                    if (Math.random() > 0.9) {
                        x *= Math.random(); z *= Math.random();
                    }
                }
                else if (shape === 'cube') {
                    const s = scale * 1.5;
                    x = (Math.random()-0.5) * s;
                    y = (Math.random()-0.5) * s;
                    z = (Math.random()-0.5) * s;
                }
                else if (shape === 'galaxy') {
                    const arms = 5;
                    const spin = idx * 15;
                    const r = idx * scale * 1.5;
                    const armOffset = (i % arms) * (Math.PI * 2 / arms);
                    
                    x = Math.cos(spin + armOffset) * r;
                    z = Math.sin(spin + armOffset) * r;
                    y = (Math.random()-0.5) * (2 - idx*2); 
                }
                else if (shape === 'heart') {
                    const t = (idx * Math.PI * 2) - Math.PI;
                    const s = scale * 0.05; 
                    x = 16 * Math.pow(Math.sin(t), 3) * s * 3;
                    y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * s * 3;
                    z = (Math.random()-0.5) * 4;
                }
                else if (shape === 'pyramid') {
                    const h = scale * 1.5;
                    const level = 1 - Math.pow(idx, 0.5); 
                    const r = (1 - level) * scale;
                    const theta = Math.random() * Math.PI * 2;
                    
                    x = r * Math.cos(theta);
                    z = r * Math.sin(theta);
                    y = (level - 0.5) * h;
                }
                else if (shape === 'torus') {
                    const R = 5; const r = 2;
                    const u = idx * Math.PI * 2 * 20;
                    const v = idx * Math.PI * 2;
                    x = (R + r * Math.cos(u)) * Math.cos(v);
                    y = (R + r * Math.cos(u)) * Math.sin(v);
                    z = r * Math.sin(u);
                }
                else if (shape === 'cone') {
                    const h = 10;
                    const level = idx; 
                    const r = level * scale;
                    const theta = Math.random() * Math.PI * 2;
                    y = -(level - 0.5) * h;
                    x = r * Math.cos(theta);
                    z = r * Math.sin(theta);
                }
                else if (shape === 'cylinder') {
                    const h = 10;
                    const r = scale * 0.8;
                    const theta = Math.random() * Math.PI * 2;
                    x = r * Math.cos(theta);
                    z = r * Math.sin(theta);
                    y = (Math.random() - 0.5) * h;
                }
                else if (shape === 'wave') {
                    const side = Math.sqrt(PARTICLE_COUNT);
                    const u = (i % side) / side;
                    const v = Math.floor(i / side) / side;
                    
                    x = (u - 0.5) * 15;
                    z = (v - 0.5) * 15;
                    y = Math.sin(u * Math.PI * 6) * 2 + Math.cos(v * Math.PI * 6) * 2;
                }
                else if (shape === 'ring') {
                    const r = scale * 1.5;
                    const theta = idx * Math.PI * 2;
                    const variation = (Math.random() * 1.5) + r;
                    x = variation * Math.cos(theta);
                    z = variation * Math.sin(theta);
                    y = (Math.random() - 0.5) * 0.5;
                }

                targetPositions[i*3] = x;
                targetPositions[i*3+1] = y;
                targetPositions[i*3+2] = z;
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // Global rotation
            particles.rotation.y += 0.002;
            particles.rotation.z = Math.sin(time * 0.2) * 0.1;

            const posAttr = particles.geometry.attributes.position;
            const currentPos = posAttr.array;

            let targetInfluence = 0.05; // Lerp speed towards the shape

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i*3;
                
                let tx = targetPositions[ix];
                let ty = targetPositions[ix+1];
                let tz = targetPositions[ix+2];

                // --- Gesture Logic ---
                if (isHandPresent) {
                    if (isFist) {
                        // Attraction: Target is the hand position
                        const handX = handPos.x * 12;
                        const handY = handPos.y * 12;
                        tx = handX; ty = handY; tz = 0;
                        targetInfluence = 0.1; // Faster attraction
                    } else {
                        // Repulsion / Explode: Target is an expanded version of the shape
                        tx *= 1.8; ty *= 1.8; tz *= 1.8;
                    }
                }

                // Lerp towards target
                currentPos[ix] += (tx - currentPos[ix]) * targetInfluence;
                currentPos[ix+1] += (ty - currentPos[ix+1]) * targetInfluence;
                currentPos[ix+2] += (tz - currentPos[ix+2]) * targetInfluence;
            }

            posAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- CAMERA SETUP AND ERROR HANDLING (REVISED FIX) ---
        const videoElement = document.getElementById('input-video');

        function displayError(message) {
            const errorInfo = document.getElementById('error-info');
            errorInfo.innerHTML = message;
            errorInfo.style.display = 'block';
            document.getElementById('video-wrapper').style.opacity = 0;
        }

        function setupCamera() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                displayError(
                    '<h2>‚ùå Media Not Supported</h2>' +
                    '<p>Your web browser does not support the required webcam access (navigator.mediaDevices.getUserMedia). The particle system will run, but hand tracking will be disabled.<br>Try on: </p><a href="https://conceptualcode-official.github.io/MinProject-ConceptualCode-official/interactive_particle_system">Interactive Particle System</a>'
                );
                return;
            }
            
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    // Success: Initialize MediaPipe CameraUtils
                    videoElement.srcObject = stream;
                    
                    const hands = new Hands({locateFile: (file) => 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/' + file});
                    hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                    hands.onResults(onResults);

                    const cameraUtils = new Camera(videoElement, {
                        onFrame: async () => { await hands.send({image: videoElement}); },
                        width: 640, height: 480
                    });
                    cameraUtils.start();
                })
                .catch(error => {
                    console.error("Camera access error:", error);
                    let errorMessage = "";

                    if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
                        // User rejected or system denied permission
                        errorMessage = 
                            '<h2>üõë Camera Access Required</h2>' +
                            '<p>Hand tracking requires temporary camera access. Please refresh the page and allow camera permissions **just this time** to enable gesture control.</p>';
                    } else if (error.name === "NotFoundError") {
                        // No camera found
                         errorMessage = 
                            '<h2>‚ö†Ô∏è No Camera Detected</h2>' +
                            '<p>No webcam device was found on your system. The particle system will run, but hand tracking is disabled.<br>Try on: </p><a href="https://conceptualcode-official.github.io/MinProject-ConceptualCode-official/interactive_particle_system">Interactive Particle System</a>';
                    } else {
                        // Other errors (e.g., technical limitations)
                        errorMessage = 
                            '<h2>‚ùå Camera Error (' + error.name + ')</h2>' +
                            '<p>A fatal error occurred while accessing the camera. Hand tracking is disabled.<br>Try on: </p><a href="https://conceptualcode-official.github.io/MinProject-ConceptualCode-official/interactive_particle_system">Interactive Particle System</a>';
                    }
                    displayError(errorMessage);
                });
        }

        // --- INPUT HANDLER (MediaPipe) ---
        // Starts around line 430 in the new version
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandPresent = true;
                const lm = results.multiHandLandmarks[0];
                
                // Track center (index finger metacarpal joint)
                handPos.x = (0.5 - lm[9].x) * 2;
                handPos.y = -(lm[9].y - 0.5) * 2;

                // Fist Check
                const wrist = lm[0];
                const tip = lm[12];
                const len = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                isFist = len < 0.25;

                // Pinch Check (Next Shape)
                const thumb = lm[4];
                const index = lm[8];
                const pinch = Math.hypot(thumb.x - index.x, thumb.y - index.y);
                
                if (pinch < 0.05) {
                    if (!isPinching && Date.now() > pinchTimer) {
                        nextShape();
                        pinchTimer = Date.now() + 1000; // 1s cooldown
                    }
                    isPinching = true;
                } else {
                    isPinching = false;
                }
            } else {
                isHandPresent = false;
            }
        }

        function nextShape() {
            currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
            calculateTargets(shapes[currentShapeIndex]);
            
            // Burst color change
            const cAttr = particles.geometry.attributes.color;
            const r = Math.random(), g = Math.random(), b = Math.random();
            for(let i=0; i<PARTICLE_COUNT; i++) {
                cAttr.setXYZ(i, r+(Math.random()*0.2), g+(Math.random()*0.2), b+(Math.random()*0.2));
            }
            cAttr.needsUpdate = true;
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
        animate();
    </script>
</body>
</html>
